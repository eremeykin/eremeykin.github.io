---
title: Strategy
tags:
- 'тип: поведенческий'
- 'уровень: компонент'
- GoF
- delegation
- indirection
- if-else
- Single Responsibility Principle
- composition vs inheritance
- dependency injection
- class explosion
- open/closed
show_excerpt: true
---
Определяет и инкапсулирует набор алгоритмов, тем самым позволяя изменять алгоритм
независимо от клиента, который делегирует ему свои функции.

<!--more-->

<style>
    .wrap {
        padding-bottom: 25px;
    }
</style>

## Назначение
Определяет и инкапсулирует набор алгоритмов, тем самым позволяя изменять алгоритм
независимо от клиента, который делегирует ему свои функции. Шаблон позволяет
достичь переиспользования кода, в тех случаях, когда требуется переиспользовать
функционал из разных частей иерархии:

<p align="center">
  <img src="/assets/images/strategy/strategy-hierarchy.png" /><br/>
  <span><i>Иерархии наследования работают только до тех пор, <br/>
  пока не надо шарить поведение горизонтально</i></span>
</p>

* Позволяет комбинировать разные реализации, которые в противном случае
требовалось бы копировать в разные классы.
* Избавляет от экспоненциального роста количества классов, так как после
реализации шаблона можно комбинировать произвольные стратегии, соединяя в одном
экземпляре различное поведение.
* Избавляет от необходимости использовать длинные ветки `if-else` и `switch-case`
* Разрешает менять поведение объекта в runtime в зависимости от выбранной
реализации стратегии, подобно шаблону State.
* Вычленяет код и зависимости из класса-контекста в отдельный класс-реализацию
конкретной стратегии, то есть изолирует эту часть логики.
* Соблюдает принцип Open/Closed - стратегии можно добавлять

## Описание
Допустим есть некоторое количество классов, у которых есть часть общего
функционала и часть специфичного. Причём специфичный функционал используется
необязательно единственным классом, он может быть задействован например, в 2-3
классах. Простейший подход к решению этой проблемы - использовать иерархию
наследования. Но не всегда можно построить такую иерархию. Например, бывает
необходимость использовать общую реализацию в разных ветках иерархии (см. рисунок).
Шаблон Strategy объединяет семейство алгоритмов / типов поведения (или стратегий)
единым интерфейсом, тем самым позволяя клиенту использовать алгоритм без знания
о конкретном классе, реализующем алгоритм. Клиент получает экземпляр через
механизм Dependency Injection (DI). Поэтому можно менять алгоритм без изменения
кода клиента, в том числе во время работы.


<p align="center">
  <img src="/assets/images/strategy/strategy-class-explosion.png" /><br/>
  <span><i>Если мы создадим общего предка для MountingDuck, CloudDuck, <br/>
  то мы всё равно не сможем разрешить проблему, которая возникнет при <br/>
  необходимости горизонтального переиспользования кода</i></span>
</p>

Частично шаблон может быть заменен применением объектов-функций (лямбд).

Проблема:

* где-то клиент, создающий контекстный класс должен определить какую именно
  стратегию требуется создать;
* согласно принципу Interface segregation, интерфейсы должны быть как можно
  более узкими, объекты не должны через интерфейс зависть от методов, которые он
  не хочет. Иногда требуется сделать объект без какого-либо поведения (та же
  нелетающая резиновая утка), но этот метод всё равно будет определён в
  интерфейсе стратегии.

## Реализация

<p align="center">
  <img src="/assets/images/strategy/strategy-class-diagram.png" />
</p>

<div class="grid grid--px-0">
  <div class="cell cell--lg-2 cell--3"><b>Client</b></div>
  <div class="cell cell--auto"><i> </i></div>
  <div class="cell cell--lg-12 wrap">Клиент, который создает (конструирует) экземпляр класса Context</div>

  <div class="cell cell--lg-2 cell--3"><b>Context</b></div>
  <div class="cell cell--auto"><i>Duck</i></div>
  <div class="cell cell--lg-12 wrap">Класс, инкапсулирующий общие характеристики и поведение для всех видов объектов. Меняет свое поведение в зависимости
от установленной через конструктор/setter стратегии. Имеет ссылку на стратегию <i>через тип интерфейса</i>.</div>

  <div class="cell cell--lg-2 cell--3"><b>Strategy</b></div>
  <div class="cell cell--auto"><i>QuackStrategy, FlyStrategy, DisplayStrategy, ...</i></div>
  <div class="cell cell--lg-12 wrap">Интерфейс, определяющий контракт всех стратегий, то есть какой функционал должна предоставлять любая стратегия.</div>

  <div class="cell cell--lg-2 cell--3"><b>ConcreteStrategy</b></div>
  <div class="cell cell--auto"><i>SimpleQuackStrategy, ShortQuackStrategy, FastFlyStrategy, ...</i></div>
  <div class="cell cell--lg-12 wrap">Конкретная реализация стратегии, содержащая в себе какие-либо особенности. Конкретная стратегия внедряется в Context через DI по ссылке типа Strategy.</div>

</div>

## Примеры

<p align="center">
    <img src="/assets/images/strategy/strategy-class-diagram-example.png" />
</p>


## Варианты
1. Можно сделать стратегию, которая ничего не делает - получится Null Object.
2. Можно для стратегий использовать абстрактный суперкласс.
## Чем отличается

**[Command](/2021/06/06/command.html)** определяет какое именно действие нужно сделать, а Strategy
определяет как делать действие, способ или алгоритм его выполнения. Command часто не содержит
логику самого действия, а просто инкапсулирует параметры и вызов на конкретном
объекте некоторого метода. Strategy часто определяет именно содержательную часть
логики, по которой выполняется действие.

Strategy - Quicksort / Mergesort - как

Command - Open / Close - что

Strategy обычно принимает параметры в методе, а команда инкапсулирует их в себе.
Команда может выполняться отложено, Strategy в момент вызова. Strategy обычно
несколько объектов (т.к. это штука без состояния), а объектов команды -- множество,
команда имеет состояние и завязана на конкретный объект, у которого она будет дергать метод.

**[Template Method](/2021/01/26/template-method.html)** позволяет менять внутренности метода, но через наследование
и переопределение, а не через делегирование, как Strategy. Наследование статично,
в отличие от делегирования.

**[Bridge](/2021/03/21/bridge.html)** является логическим расширением шаблона Strategy, то есть
частный случай Bridge c одним классом абстракции по сути и есть Strategy.

**[Observer](/2021/06/28/observer.html)** можно рассматривать в некотором смысле как частный случай Strategy. Способ
реагирования на измененное состояние наблюдаемого объекта можно назвать стратегией.

**[Decorator](/2021/05/05/decorator.html)** через делегирование позволяет менять поведение объекта.

## Ссылки
[https://java-design-patterns.com/patterns/strategy/](https://java-design-patterns.com/patterns/strategy/)

[https://github.com/iluwatar/java-design-patterns/tree/master/strategy](https://github.com/iluwatar/java-design-patterns/tree/master/strategy)

[https://refactoring.guru/design-patterns/strategy](https://refactoring.guru/design-patterns/strategy)

[Baeldung - The Observer Pattern in Java](https://www.baeldung.com/java-strategy-pattern)

[YouTube: Strategy Pattern – Design Patterns (ep 1)](https://youtu.be/v9ejT8FO-7I)
